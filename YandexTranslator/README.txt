В меру ограниченности во времени (на данный момент я заканчиваю сотрудничество с компанией, поэтому ещё на фултайме) решение вышло незаконченным.

Время выполнения: 2 недели (3 часа в день в нерабочее время)

Почему VIPER? -Для такой задачи с достаточно богатым функционалом и непростой бизнес-логикой MVC не годится, потому что он бы превратился в Massive Controller, что не есть хорошо

В чём преимущество: гибкая, легко расширяемая и контролируемая система

-Гибкость: сегодня нам нужно, чтобы отображение перевода было в формате Message-ей, а вдруг завтра нам нужно заменить вьюшку на другую? (передали в презентер - другое View, реализующее общепринятый в системе протокол - и заменили, всё продолжает работать)

-Контролируемость и автономность: лид согласовал все архитектурные моменты (какие будут протоколы и за что будут отвечать), что позволяет делегирование выполнения работы над проектом, всё делится на компоненты (пока кто-то занимается юайкой, другой человек работает с логикой Interactor-а, сервисами и т.п.)

Какое решение я вижу и что проработано?

V - view
I - interactor
P - presenter
E - entity
R - router (wireframe)

Router - готовит наш экран к отображению, его главная задача: настройка ViewController. Моё видение: хранить директорию с иконками, соответствующими разным языкам, цвета и т.д. Router будет отвечать за переход (т.е. в зависимости от того, какую пару языков выберет юзер, к примеру, с NavigationController-a - Router будет отвественен за то, чтобы правильно настроить View (установить иконки языков, цвета и другие базовые моменты инициализации), создание и настройку связей между View, Presenter, Interactor)

View - в моём случае представлен классом TranslatorViewController.
Выполнено мной: кастомный компонент (xib файл TranslatorView), отвечающий за ввод данных. Кастомная кнопочка TranslatorButton с анимацией.

Альтернатива моему подходу: создать кнопку овальной формы, где ползуясь Graphics и Animation, будут отрисовываться и перемещаться при обработке клика кружочки-флажки

Мессенджерный output: я вижу это как динамическую таблицу с ячеечками, обретающими нужную форму и позиционарование в зависимости от типа сообщения (приходящее, исходящее)

Что View должно передавать в Presenter:
    -при клике по языковой кнопке передать презетеру, чтобы тот поменял главный язык

с кнопкой отправки отдельная тема: исходя из демо-видео эта кнопка должна описываться машиной состояний, я отрисовала граф переходов из одного состояния в другое (по максимуму задействуем поведенческие паттерны гоффа: Strategy и State). А вдруг у нас появится ещё какой-то режим кнопки (с фотки перевод вытянуть, к примеру), применение такого подхода упростит измение состояний

    -строка с текстом, который необходимо перевести
    -изменение главного языка при его переключении на клавиатуре

Presenter - принимает все изменения, которые описаны выше и передаёт на обработку Interactor-у, потом примет результаты обработки от Interactor-а и передаст вьюшке, чтобы она изменилась (в нашем случае - переведенное сообщение)

Interactor - бизнес-логика обработки данных, приходящих из Presenter-а. Здесь мы подтягиваем наш сетевой сервис, который стучится к API-ке.

В моём случае: для работы с сетью применялся framework Moya, были организованы POST-запросы. Как я проверяла корректность работы запросов: закидывала аналогичные запросы через вспомогательную программу Postman, сравнивала на соотвествие: что выдавало в ответе в Postman-e и что выдавало у меня при парсинге Json-ответа.

Моё видение организации связи между сервисом, который выполняет запросы, принимая их и осуществляя парсинг в json формате и самим Interactor с бизнес-логикой: выделить общий интерфейс, описывающий основной набор действий: получить список языков, перевести сообщение и т.д. Который и будет реализован конкретным сервисом, а к самим методам интерфейса будет идти обращение в Interactor. Зачем так? - А вдруг завтра можно будет получать данные только в формате XML? А у нас на этот случай уже есть протокол, который как раз-таки и описывает получение данных в общем виде. Это упростит подмену на другой сервис, позволяющий организовать и парсить запросы в другом формате.
